import { Link, Typography } from "@mui/material";
import Image from "next/image";
import ImageModal from "@/app/components/ImageModal";
import CodeBlock from "@/app/components/CodeBlock";

const page = () => {

  const text = `Here is a scenario that might explain things

You declare a dependency in package.json like:
"depA": "^1.0.0"

Then you do, npm install which will generate a package-lock.json with:
"depA": "1.0.0"

Few days later, a newer minor version of "depA" is released, say "1.1.0", 
then the following holds true:

npm ci           # respects only package-lock.json and installs 1.0.0
npm install  # also, respects the package-lock version and keeps 1.0.0 installed 
             		  # (i.e. when package-lock.json exists, it overrules package.json)

Next, you manually update your package.json to:
"depA": "^1.1.0"

Then re-run:
npm ci      # will try to honor package-lock which says 1.0.0
           		 # but that does not satisfy package.json requirement of "^1.1.0" 
            	# so it would throw an error 

npm install # installs "1.1.0" (as required by the updated package.json)
            # also rewrites package-lock.json version to "1.1.0"
            # (i.e. when package.json is modified, it overrules the package-lock.json)
	
The Common Mistake: Ignoring package-lock.json
Many developers think of package-lock.json as just noise.
Since it's autogenerated, why not just regenerate it every time?


Why You Should Never gitignore package-lock.json
Here’s why that’s a terrible idea:

package-lock.json locks the exact versions of dependencies (and their dependencies) so everyone on the team, your CI, and your production server runs the same code.

Without it, npm install may pull newer, incompatible versions of packages — even if your package.json versions appear safe.

Ignoring it means every environment might resolve packages differently — leading to bugs that are painful to trace and fix.

The Best Practice: Commit package-lock.json to Git

The official npm docs say it best:

“It is highly recommended you commit the generated package-lock to source control: this will allow anyone else on your team, your deployments, your CI/continuous integration, and anyone else who runs npm install in your package source to get the exact same dependency tree that you were developing on."

Benefits:
Reproducible builds — what works on one machine works everywhere.
Predictable dependency tree — no surprises when libraries auto-update.
Readable diffs — helps you track and audit dependency changes.
Increased security — no sneaky package changes or breaking transitive dependencies.
The Life Hack: Use npm ci Instead of npm install
Here’s the real gem.`;

  return (
    <div className='text-sm'>
      <div className="flex items-center mt-5">
        <Image src="/gitlab-logo-500-svg.svg" width={70} height={0} className="-mt-8" alt="GitLab logo" />
        <Typography variant="h6" sx={{ fontWeight: '600' }} mb={4}>
				When package-lock.json exists, it overrules package.json
        </Typography>
      </div>
      <Typography variant="body1" mb={4} sx={{ whiteSpace: 'pre-wrap', lineHeight: '1.5em' }}>
        {text}
      </Typography>
      <ImageModal img={"/package-lock.jpg"} />
    </div>
  )
}

export default page